# üö§ LeetCode 881 ‚Äì Boats to Save People

## Problem Statement
You are given an array `people` where `people[i]` is the weight of the `i`-th person, and an integer `limit` which is the maximum weight a boat can carry.  

- Each boat carries **at most two people**.  
- The sum of weights of the people on board must be **at most `limit`**.  
- Return the **minimum number of boats** needed to carry everyone.

---

## Approach üöÄ
- **Sort the array** of people‚Äôs weights.  
- Use a **two-pointer greedy strategy**:
  - Pair the **lightest** (`l`) and **heaviest** (`r`) person if possible.  
  - If they fit ‚Üí move both pointers.  
  - Otherwise ‚Üí put the heaviest person (`r`) alone in a boat.  
- Always increment the boat counter.  
- Continue until all people are assigned.

---

## Complexity ‚è≥
- **Time Complexity:** `O(n log n)` (sorting dominates).  
- **Space Complexity:** `O(1)` (just pointers and counters).  

---

## C++ Solution üíª
```cpp
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        int n = people.size();
        int l = 0, r = n - 1;
        sort(people.begin(), people.end());
        int boats = 0;

        while (l <= r) {
            if (people[l] + people[r] <= limit) {
                l++;
                r--;
            } else {
                r--;
            }
            boats++;
        }
        return boats;
    }
};

# üéØ LeetCode 948 ‚Äì Bag of Tokens

## Problem Statement
You are given an integer array `tokens` and an initial integer `power`.

- You can play tokens **face up** (spend `power` and gain `+1` score).  
- You can play tokens **face down** (spend `1` score and regain `power`).  
- Each token can be used **at most once**.  
- Your goal is to maximize your score and return it.

---

## Approach üöÄ
- **Sort tokens** to access the smallest and largest efficiently.  
- Use **two pointers**:
  - If you have enough `power`, play the **smallest token face up** to gain score.  
  - Otherwise, if you have at least `1` score, play the **largest token face down** to regain power.  
- Track the **maximum score** reached.  
- Stop when no further moves are possible.  

---

## Complexity ‚è≥
- **Time Complexity:** `O(n log n)` (sorting dominates).  
- **Space Complexity:** `O(1)` (two pointers + counters).  

---

## C++ Solution üíª
```cpp
class Solution {
public:
    int bagOfTokensScore(vector<int>& tokens, int power) {
        int n = tokens.size();
        sort(tokens.begin(), tokens.end());

        int score = 0, maxscore = 0;
        int i = 0, j = n - 1;

        while (i <= j) {
            if (power >= tokens[i]) {
                power -= tokens[i];
                score += 1;
                i++;
                maxscore = max(maxscore, score);
            } else if (score > 0) {
                power += tokens[j];
                score -= 1;
                j--;
            } else {
                break;
            }
        }
        return maxscore;
    }
};


# üé® LeetCode 1578 ‚Äì Minimum Time to Make Rope Colorful

## Problem Statement
You are given:
- A string `colors` where each character represents the color of a balloon.
- An integer array `neededTime` where `neededTime[i]` is the time to remove the `i`-th balloon.

You must remove some balloons so that **no two adjacent balloons have the same color**.  
Return the **minimum time** needed to achieve this.

---

## Approach üöÄ
- Traverse the balloons one by one.  
- Whenever you find **consecutive balloons of the same color**, you must remove one.  
- Greedy choice:  
  - Always **keep the balloon with the maximum `neededTime`**.  
  - Remove the rest ‚Üí accumulate their times.  
- Use a variable `prev` to track the maximum time in the current color group.

---

## Complexity ‚è≥
- **Time Complexity:** `O(n)` (single pass through balloons).  
- **Space Complexity:** `O(1)` (just counters).  

---

## C++ Solution üíª
```cpp
class Solution {
public:
    int minCost(string colors, vector<int>& neededTime) {
        int n = colors.length();
        int prev = 0;
        int time = 0;

        for (int i = 0; i < n; i++) {
            if (i > 0 && colors[i] != colors[i - 1]) {
                prev = 0;
            }
            int cur = neededTime[i];
            time += min(prev, cur);
            prev = max(prev, cur);
        }
        return time;
    }
};
